<script>
	import Router from './Components/Router.html';
	import Route from './Components/Route.html';
	import HomeRoute from './Components/test/HomeRoute.html';
	import Error from './Components/test/Error.html';

	const exampleRouterMiddleware = (ctx,next) => {
		console.log(`This runs for every route in instance of Router\n${JSON.stringify(ctx,null,2)}`); 
		next(); 
	};

	const exampleRouteMiddleware = (ctx,next) => {
		console.log(`This runs only for specific routes where it is applied\n${JSON.stringify(ctx,null,2)}`); 
		next(); 
	};

	const exampleRouterMetadata = { routerId: 123 };
	const exampleRouteMetadata = { pageName: 'Home (Alt)' }; 
</script>

<div>
	<Router 
		hashbang={true}
		ErrorComponent={Error}
		middleware={[exampleRouterMiddleware]}
		metadata={exampleRouterMetadata}
	>
		<!-- Route paths can be strings (exact matches or express-style named-params) or regex -->
		<!-- Components can  be embedded via the component prop -->
		<Route 
			path='/' 
			component={HomeRoute}
		/>
		<!-- Components/DOM can also be embedded via the "component" slot -->
		<Route
			path='/home-alt'
			middleware={[exampleRouteMiddleware]}
			metadata={exampleRouteMetadata}
		>
			<div slot="component">
				<HomeRoute />
			</div>
		</Route>
		<!-- 
			asyncComponent is an optional prop which provides a function which 
			dynamically imports the necessary component for a route 
		-->
		<Route 
			path={/\/regex-route\.(\d+)/} 
			asyncComponent={() => import('./Components/test/RegexRoute.html')} 
		/>
		<Route 
			path='/named/:id' 
			asyncComponent={() => import('./Components/test/NamedParamsRoute.html')} 
		>
			<!-- 
				with asynchronously loaded route components you can also specify 
				loading and error slots on a per-route basis
			 -->
			 <div slot="loading">LOADING...</div>
			 <div slot="error">ERROR!</div>
		</Route>
	</Router>
</div>