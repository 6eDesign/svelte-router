{"version":3,"file":"test.js","sources":["../../node_modules/es6-object-assign/index.js","../../node_modules/svelte/store.mjs","../../src/lib/determineRoute.js","../../src/Components/Router.html","../../src/Components/Route.html","../../src/App.html","../../src/test.js"],"sourcesContent":["/**\n * Code refactored from Mozilla Developer Network:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n */\n\n'use strict';\n\nfunction assign(target, firstSource) {\n  if (target === undefined || target === null) {\n    throw new TypeError('Cannot convert first argument to object');\n  }\n\n  var to = Object(target);\n  for (var i = 1; i < arguments.length; i++) {\n    var nextSource = arguments[i];\n    if (nextSource === undefined || nextSource === null) {\n      continue;\n    }\n\n    var keysArray = Object.keys(Object(nextSource));\n    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n      var nextKey = keysArray[nextIndex];\n      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n      if (desc !== undefined && desc.enumerable) {\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n  }\n  return to;\n}\n\nfunction polyfill() {\n  if (!Object.assign) {\n    Object.defineProperty(Object, 'assign', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: assign\n    });\n  }\n}\n\nmodule.exports = {\n  assign: assign,\n  polyfill: polyfill\n};\n","import { run_all, noop } from './internal';\n\nexport function readable(start, value) {\n\tconst subscribers = [];\n\tlet stop;\n\n\tfunction set(newValue) {\n\t\tif (newValue === value) return;\n\t\tvalue = newValue;\n\t\tsubscribers.forEach(s => s[1]());\n\t\tsubscribers.forEach(s => s[0](value));\n\t}\n\n\treturn {\n\t\tsubscribe(run, invalidate = noop) {\n\t\t\tif (subscribers.length === 0) {\n\t\t\t\tstop = start(set);\n\t\t\t}\n\n\t\t\tconst subscriber = [run, invalidate];\n\t\t\tsubscribers.push(subscriber);\n\t\t\trun(value);\n\n\t\t\treturn function() {\n\t\t\t\tconst index = subscribers.indexOf(subscriber);\n\t\t\t\tif (index !== -1) subscribers.splice(index, 1);\n\n\t\t\t\tif (subscribers.length === 0) {\n\t\t\t\t\tstop && stop();\n\t\t\t\t\tstop = null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n}\n\nexport function writable(value) {\n\tconst subscribers = [];\n\n\tfunction set(newValue) {\n\t\tif (newValue === value) return;\n\t\tvalue = newValue;\n\t\tsubscribers.forEach(s => s[1]());\n\t\tsubscribers.forEach(s => s[0](value));\n\t}\n\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\tfunction subscribe(run, invalidate = noop) {\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.push(subscriber);\n\t\trun(value);\n\n\t\treturn () => {\n\t\t\tconst index = subscribers.indexOf(subscriber);\n\t\t\tif (index !== -1) subscribers.splice(index, 1);\n\t\t};\n\t}\n\n\treturn { set, update, subscribe };\n}\n\nexport function derive(stores, fn) {\n\tconst single = !Array.isArray(stores);\n\tif (single) stores = [stores];\n\n\tconst auto = fn.length === 1;\n\tlet value = {};\n\n\treturn readable(set => {\n\t\tlet inited = false;\n\t\tconst values = [];\n\n\t\tlet pending = 0;\n\n\t\tconst sync = () => {\n\t\t\tif (pending) return;\n\t\t\tconst result = fn(single ? values[0] : values, set);\n\t\t\tif (auto && (value !== (value = result))) set(result);\n\t\t}\n\n\t\tconst unsubscribers = stores.map((store, i) => store.subscribe(\n\t\t\tvalue => {\n\t\t\t\tvalues[i] = value;\n\t\t\t\tpending &= ~(1 << i);\n\t\t\t\tif (inited) sync();\n\t\t\t},\n\t\t\t() => {\n\t\t\t\tpending |= (1 << i);\n\t\t\t})\n\t\t);\n\n\t\tinited = true;\n\t\tsync();\n\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t};\n\t});\n}\n","const isNamedParam = str => str.length > 2 && str.indexOf(':') == 0; \r\n\r\nconst testString = (routeString, path) => { \r\n  let params = { }; \r\n  if(routeString.indexOf(':') == -1) { \r\n    return routeString === path ? params : false;\r\n  }\r\n  const pathParts = path.substring(1).split('/'); \r\n  const routeParts = routeString.substring(1).split('/');\r\n  if(pathParts.length !== routeParts.length) return false;\r\n  for (var i = 0; i < pathParts.length; ++i) { \r\n    if(isNamedParam(routeParts[i])) { \r\n      params[routeParts[i].substring(1)] = pathParts[i]; \r\n      continue; \r\n    }\r\n    if(pathParts[i] !== routeParts[i]) return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nconst matchRoute = (route, path) => { \r\n  switch(typeof route.path) { \r\n    case 'string': \r\n      return testString(route.path, path); \r\n    case 'function': \r\n      return route.path(path);\r\n    case 'object': \r\n      if(!(route.path instanceof RegExp)) return false;\r\n      return route.path.test(path);\r\n      break;\r\n    default: \r\n      return false;\r\n  }\r\n};\r\n\r\nexport default function determineRoute(routes, path) { \r\n  for(var i=0; i < routes.length; ++i) { \r\n    let params = matchRoute(routes[i], path); \r\n    if(params) { \r\n      return { route: routes[i], params }; \r\n    }\r\n  }\r\n  return null;\r\n}","<script context=\"module\">\n\texport const ROUTER = { }; \n</script>\n\n<script>\n\timport { setContext, onMount } from 'svelte';\n\timport { writable, derive } from 'svelte/store';\n\timport determineRoute from '../lib/determineRoute';\n\t\n\tlet routes = writable([]);\n\tlet path = writable(null);\n\tlet selectedRoute = derive([routes, path], ([routes, path]) => { \n\t\tif(!path || !routes) return null;\n\t\tlet route = determineRoute(routes,path);\n\t\treturn route;\n\t}); \n\n\tconst locationChange = () => { \n\t\tpath.set(location.pathname); \n\t}; \n\t\n\tsetContext(ROUTER, { \n\t\tregisterRoute(conf) { \n\t\t\troutes.update(current => { \n\t\t\t\tcurrent.push(conf);\n\t\t\t\treturn current;\n\t\t\t});\n\t\t}, \n\t\tselectedRoute\n\t});\n\n\tonMount(locationChange);\n\t\n</script>\n\n<svelte:window \n\ton:hashchange={locationChange} \n\ton:popstate={locationChange} \n/>\n<slot></slot>","<script>\n\timport { getContext, onDestroy } from 'svelte';\n\timport { ROUTER } from './Router.html';\n\n\texport let path; \n\texport let componentImport;\n\n\tlet ComponentPromise; \n\n\tconst route = { path, componentImport };\n\n\tconst { registerRoute, unregisterRoute, selectedRoute } = getContext(ROUTER);\n\t\n\tregisterRoute(route);\n\n\tselectedRoute.subscribe(val => {\n\t\tif(val && val.route == route) {\n\t\t\tconsole.log(`Dynamically importing route \"${route.path}\"`);\n\t\t\tComponentPromise = componentImport().then(({default: comp}) => {\n\t\t\t\tconsole.log(comp);\n\t\t\t\treturn comp;\n\t\t\t}); \n\t\t}\n\t});\n\t\n</script>\n\n{#if $selectedRoute && $selectedRoute.route == route}\n\t{#await ComponentPromise}\n\t\t<slot>\n\t\t\t<p>Loading... {JSON.stringify($selectedRoute,null,2)}</p>\n\t\t</slot>\n\t{:then something}\n\t\tLoaded! {Component}\n\t\t<!-- <Component params={$selectedRoute.params} /> -->\n\t{/await}\n{/if}","<script>\n\timport Router from './Components/Router.html';\n\timport Route from './Components/Route.html';\n</script>\n\n<Router>\n\t<!-- Route paths can be strings (exact matches or express-style named-params) or regex -->\n\t<!-- componentImport is a function which dynamically imports the necessary component -->\n\t<Route path='/' componentImport={() => import('./Components/Home.html')} />\n</Router>","import { polyfill } from \"es6-object-assign\";\npolyfill();\nimport App from \"./App.html\";\n\nconst app = new App({\n  target: document.body,\n  data: {}\n});\n\nexport default app;"],"names":["assign","target","firstSource","TypeError","to","Object","i","arguments","length","nextSource","keysArray","keys","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","undefined","enumerable","polyfill","defineProperty","configurable","writable","value","readable","start","const","stop","subscribers","set","newValue","forEach","s","subscribe","run","invalidate","noop","subscriber","push","index","indexOf","splice","fn","derive","stores","single","Array","isArray","auto","let","inited","values","pending","sync","result","unsubscribers","map","store","run_all","isNamedParam","str","testString","routeString","path","params","pathParts","substring","split","routeParts","matchRoute","route","RegExp","test","determineRoute","routes","locationChange","ROUTER","selectedRoute","ref","location","pathname","setContext","registerRoute","conf","update","current","onMount","ComponentPromise","Component","JSON","stringify","$selectedRoute","componentImport","getContext","val","console","log","then","comp","func","app","App","document","body","data"],"mappings":"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"}