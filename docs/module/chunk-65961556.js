import { a as SvelteComponentDev, b as addLoc, c as add_binding_callback, d as assign, e as createComment, f as createElement, g as createText, h as create_slot, i as detachNode, j as flush, k as get_slot_context, l as handlePromise, m as init, n as insert, o as noop, p as safe_not_equal, q as validate_store, r as getContext, s as setContext, t as writable, u as ROUTER } from './chunk-308b0065.js';

/* src\Components\Route.html generated by Svelte v3.0.0-alpha20 */

const file = "src\\Components\\Route.html";

// (48:0) {#if $selectedRoute && $selectedRoute.route == route}
function create_if_block(ctx) {
	var if_block_anchor;

	function select_block_type(ctx) {
		if (ctx.asyncComponent) return create_if_block_1;
		return create_else_block;
	}

	var current_block_type = select_block_type(ctx);
	var if_block = current_block_type(ctx);

	return {
		c: function create() {
			if_block.c();
			if_block_anchor = createComment();
		},

		m: function mount(target_1, anchor) {
			if_block.m(target_1, anchor);
			insert(target_1, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},

		d: function destroy(detach) {
			if_block.d(detach);

			if (detach) {
				detachNode(if_block_anchor);
			}
		}
	};
}

// (61:1) {:else}
function create_else_block(ctx) {
	const component_slot_1 = ctx.$$slot_component;
	const component_slot = create_slot(component_slot_1, ctx, null);

	return {
		c: function create() {

			if (component_slot) component_slot.c();
		},

		l: function claim(nodes) {
			if (component_slot) component_slot.l(nodes);
		},

		m: function mount(target_1, anchor) {

			if (component_slot) {
				component_slot.m(target_1, anchor);
			}
		},

		p: function update(changed, ctx) {

			if (component_slot && changed.$$scope) {
				component_slot.p(assign(assign({},(changed)), ctx.$$scope.changed), get_slot_context(component_slot_1, ctx, null));
			}
		},

		d: function destroy(detach) {

			if (component_slot) component_slot.d(detach);
		}
	};
}

// (49:1) {#if asyncComponent}
function create_if_block_1(ctx) {
	var promise, text, div;

	let info = {
		ctx,
		current: null,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 'null',
		error: 'null'
	};

	handlePromise(promise = ctx.componentPromise, info);

	return {
		c: function create() {
			info.block.c();

			text = createText("\n\t\t");
			div = createElement("div");
			addLoc(div, file, 59, 2, 1288);
		},

		m: function mount(target_1, anchor) {
			info.block.m(target_1, info.anchor = anchor);
			info.mount = () => text.parentNode;
			info.anchor = text;

			insert(target_1, text, anchor);
			insert(target_1, div, anchor);
			add_binding_callback(() => ctx.div_binding(div, null));
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (('componentPromise' in changed) && promise !== (promise = ctx.componentPromise) && handlePromise(promise, info)) ; else {
				info.block.p(changed, assign(assign({}, ctx), info.resolved));
			}

			if (changed.items) {
				ctx.div_binding(null, div);
				ctx.div_binding(div, null);
			}
		},

		d: function destroy(detach) {
			info.block.d(detach);
			info = null;

			if (detach) {
				detachNode(text);
				detachNode(div);
			}

			ctx.div_binding(null, div);
		}
	};
}

// (55:2) {:catch}
function create_catch_block(ctx) {
	var text;

	const error_slot_1 = ctx.$$slot_error;
	const error_slot = create_slot(error_slot_1, ctx, null);

	return {
		c: function create() {
			if (!error_slot) {
				text = createText("Error!");
			}

			if (error_slot) error_slot.c();
		},

		l: function claim(nodes) {
			if (error_slot) error_slot.l(nodes);
		},

		m: function mount(target_1, anchor) {
			if (!error_slot) {
				insert(target_1, text, anchor);
			}

			else {
				error_slot.m(target_1, anchor);
			}
		},

		p: function update(changed, ctx) {

			if (error_slot && changed.$$scope) {
				error_slot.p(assign(assign({},(changed)), ctx.$$scope.changed), get_slot_context(error_slot_1, ctx, null));
			}
		},

		d: function destroy(detach) {
			if (!error_slot) {
				if (detach) {
					detachNode(text);
				}
			}

			if (error_slot) error_slot.d(detach);
		}
	};
}

// (54:2) {:then}
function create_then_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		d: noop
	};
}

// (50:27)     <slot name="loading">     <p>Loading... </p>    </slot>   {:then}
function create_pending_block(ctx) {
	var p;

	const loading_slot_1 = ctx.$$slot_loading;
	const loading_slot = create_slot(loading_slot_1, ctx, null);

	return {
		c: function create() {
			if (!loading_slot) {
				p = createElement("p");
				p.textContent = "Loading...";
			}

			if (loading_slot) loading_slot.c();
			if (!loading_slot) {
				addLoc(p, file, 51, 4, 1179);
			}
		},

		l: function claim(nodes) {
			if (loading_slot) loading_slot.l(nodes);
		},

		m: function mount(target_1, anchor) {
			if (!loading_slot) {
				insert(target_1, p, anchor);
			}

			else {
				loading_slot.m(target_1, anchor);
			}
		},

		p: function update(changed, ctx) {

			if (loading_slot && changed.$$scope) {
				loading_slot.p(assign(assign({},(changed)), ctx.$$scope.changed), get_slot_context(loading_slot_1, ctx, null));
			}
		},

		d: function destroy(detach) {
			if (!loading_slot) {
				if (detach) {
					detachNode(p);
				}
			}

			if (loading_slot) loading_slot.d(detach);
		}
	};
}

function create_fragment(ctx) {
	var if_block_anchor;

	var if_block = (ctx.$selectedRoute && ctx.$selectedRoute.route == ctx.route) && create_if_block(ctx);

	return {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = createComment();
		},

		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target_1, anchor) {
			if (if_block) if_block.m(target_1, anchor);
			insert(target_1, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (ctx.$selectedRoute && ctx.$selectedRoute.route == ctx.route) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detach) {
			if (if_block) if_block.d(detach);

			if (detach) {
				detachNode(if_block_anchor);
			}
		}
	};
}

const ROUTE = { };

function instance($$self, $$props, $$invalidate) {
	

	const { registerRoute, selectedRoute } = getContext(ROUTER);

	// props
	let { path, asyncComponent = null } = $$props;

	// template variables
	let componentPromise; 
	let target;

	const route = { path, asyncComponent, ctx: { } };

	setContext(ROUTE, route);
	
	registerRoute(route);
	selectedRoute.subscribe(selected => {
		if(!selected) return;
		route.ctx = selected.ctx; $$invalidate('route', route);
		if(asyncComponent && selected && selected.route == route) {
			componentPromise = Promise.all([
				asyncComponent(), 
				// todo: optionally fetch data/props concurrently with component import?
			])
			.then(([{default: Component}, props]) => {
				return new Component({
					target
				});
			})
			.catch(err => {
				console.log('Todo: handle error with generic/specific handler:\n', err);
				throw err;
			}); $$invalidate('componentPromise', componentPromise); 
		}
	});

	let { $$slot_loading, $$slot_error, $$slot_component, $$scope } = $$props;

	function div_binding($$node, check) {
		target = $$node;
		$$invalidate('target', target);
	}

	let $selectedRoute;
	validate_store(selectedRoute, 'selectedRoute');
	$$self.$$.on_destroy.push(selectedRoute.subscribe($$value => { $selectedRoute = $$value; $$invalidate('$selectedRoute', $selectedRoute); }));

	$$self.$set = $$props => {
		if ('path' in $$props) $$invalidate('path', path = $$props.path);
		if ('asyncComponent' in $$props) $$invalidate('asyncComponent', asyncComponent = $$props.asyncComponent);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		path,
		asyncComponent,
		componentPromise,
		target,
		route,
		div_binding,
		$selectedRoute,
		$$slot_loading,
		$$slot_error,
		$$slot_component,
		$$scope
	};
}

class Route extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.path === undefined && !('path' in props)) {
			console.warn("<Route> was created without expected prop 'path'");
		}
		if (ctx.asyncComponent === undefined && !('asyncComponent' in props)) {
			console.warn("<Route> was created without expected prop 'asyncComponent'");
		}
	}

	get path() {
		return this.$$.ctx.path;
	}

	set path(path) {
		this.$set({ path });
		flush();
	}

	get asyncComponent() {
		return this.$$.ctx.asyncComponent;
	}

	set asyncComponent(asyncComponent) {
		this.$set({ asyncComponent });
		flush();
	}
}

export { ROUTE as a, Route as b };
//# sourceMappingURL=chunk-65961556.js.map
