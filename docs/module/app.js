import { a as SvelteComponentDev, b as addLoc, c as createElement, d as detachNode, e as init, f as insert, g as noop, h as safe_not_equal, i as createText, j as flush, k as setData, l as add_binding_callback, m as assign, n as check_outros, o as createComment, p as create_slot, q as get_slot_context, r as group_outros, s as handlePromise, t as mount_component, u as on_outro, v as validate_store, w as getContext, x as writable, y as ROUTER, z as append, A as Router } from './chunk-059d1f2a.js';

/* src\Components\Loading.html generated by Svelte v3.0.0-alpha20 */

var file = "src\\Components\\Loading.html";

function create_fragment(ctx) {
	var p;

	return {
		c: function create() {
			p = createElement("p");
			p.textContent = "Loading...";
			addLoc(p, file, 0, 0, 0);
		},

		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target, anchor) {
			insert(target, p, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detach) {
			if (detach) {
				detachNode(p);
			}
		}
	};
}

var Loading = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function Loading(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, null, create_fragment, safe_not_equal);
	}

	if ( SvelteComponentDev$$1 ) Loading.__proto__ = SvelteComponentDev$$1;
	Loading.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	Loading.prototype.constructor = Loading;

	return Loading;
}(SvelteComponentDev));

/* src\Components\Error.html generated by Svelte v3.0.0-alpha20 */

var file$1 = "src\\Components\\Error.html";

function create_fragment$1(ctx) {
	var h1, text1, p, text3, text4;

	return {
		c: function create() {
			h1 = createElement("h1");
			h1.textContent = "ERROR!";
			text1 = createText("\r\n\r\n");
			p = createElement("p");
			p.textContent = "Error:";
			text3 = createText("\r\n");
			text4 = createText(ctx.error);
			addLoc(h1, file$1, 4, 0, 51);
			addLoc(p, file$1, 6, 0, 70);
		},

		l: function claim(nodes) {
			throw new Error$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target, anchor) {
			insert(target, h1, anchor);
			insert(target, text1, anchor);
			insert(target, p, anchor);
			insert(target, text3, anchor);
			insert(target, text4, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.error) {
				setData(text4, ctx.error);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detach) {
			if (detach) {
				detachNode(h1);
				detachNode(text1);
				detachNode(p);
				detachNode(text3);
				detachNode(text4);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	var error = $$props.error; if ( error === void 0 ) error = null;

	$$self.$set = function ($$props) {
		if ('error' in $$props) { $$invalidate('error', error = $$props.error); }
	};

	return { error: error };
}

var Error$1 = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function Error(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, instance, create_fragment$1, safe_not_equal);

		var ref = this.$$;
		var ctx = ref.ctx;
		var props = options.props || {};
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<Error> was created without expected prop 'error'");
		}
	}

	if ( SvelteComponentDev$$1 ) Error.__proto__ = SvelteComponentDev$$1;
	Error.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	Error.prototype.constructor = Error;

	var prototypeAccessors = { error: { configurable: true } };

	prototypeAccessors.error.get = function () {
		return this.$$.ctx.error;
	};

	prototypeAccessors.error.set = function (error) {
		this.$set({ error: error });
		flush();
	};

	Object.defineProperties( Error.prototype, prototypeAccessors );

	return Error;
}(SvelteComponentDev));

/* src\Components\Route.html generated by Svelte v3.0.0-alpha20 */

var file$2 = "src\\Components\\Route.html";

// (58:0) {#if $selectedRoute && $selectedRoute.route == route}
function create_if_block(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block_1,
		create_if_block_2,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.asyncComponent) { return 0; }
		if (ctx.component) { return 1; }
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c: function create() {
			if_block.c();
			if_block_anchor = createComment();
		},

		m: function mount(target_1, anchor) {
			if_blocks[current_block_type_index].m(target_1, anchor);
			insert(target_1, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				on_outro(function () {
					if_blocks[previous_block_index].d(1);
					if_blocks[previous_block_index] = null;
				});
				if_block.o();
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
				if_block.i();
			}
		},

		i: function intro() {
			if (current) { return; }
			if (if_block) { if_block.i(); }
			current = true;
		},

		o: function outro() {
			if (if_block) { if_block.o(); }
			current = false;
		},

		d: function destroy(detach) {
			if_blocks[current_block_type_index].d(detach);

			if (detach) {
				detachNode(if_block_anchor);
			}
		}
	};
}

// (69:1) {:else}
function create_else_block(ctx) {
	var default_slot_1 = ctx.$$slot_default;
	var default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c: function create() {

			if (default_slot) { default_slot.c(); }
		},

		l: function claim(nodes) {
			if (default_slot) { default_slot.l(nodes); }
		},

		m: function mount(target_1, anchor) {

			if (default_slot) {
				default_slot.m(target_1, anchor);
			}
		},

		p: function update(changed, ctx) {

			if (default_slot && changed.$$scope) {
				default_slot.p(assign(assign({},(changed)), ctx.$$scope.changed), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detach) {

			if (default_slot) { default_slot.d(detach); }
		}
	};
}

// (67:20) 
function create_if_block_2(ctx) {
	var switch_instance_anchor, current;

	var switch_value = ctx.component;

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c: function create() {
			if (switch_instance) { switch_instance.$$.fragment.c(); }
			switch_instance_anchor = createComment();
		},

		m: function mount(target_1, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target_1, anchor);
			}

			insert(target_1, switch_instance_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (switch_value !== (switch_value = ctx.component)) {
				if (switch_instance) {
					group_outros();
					var old_component = switch_instance;
					on_outro(function () {
						old_component.$destroy();
					});
					old_component.$$.fragment.o();
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					switch_instance.$$.fragment.i();
				} else {
					switch_instance = null;
				}
			}
		},

		i: function intro() {
			if (current) { return; }
			if (switch_instance) { switch_instance.$$.fragment.i(); }

			current = true;
		},

		o: function outro() {
			if (switch_instance) { switch_instance.$$.fragment.o(); }
			current = false;
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(switch_instance_anchor);
			}

			if (switch_instance) { switch_instance.$destroy(detach); }
		}
	};
}

// (59:1) {#if asyncComponent}
function create_if_block_1(ctx) {
	var promise, text, div, current;

	var info = {
		ctx: ctx,
		current: null,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 'null',
		error: 'error',
		blocks: Array(3)
	};

	handlePromise(promise = ctx.componentPromise, info);

	return {
		c: function create() {
			info.block.c();

			text = createText("\n\t\t");
			div = createElement("div");
			addLoc(div, file$2, 65, 2, 1569);
		},

		m: function mount(target_1, anchor) {
			info.block.m(target_1, info.anchor = anchor);
			info.mount = function () { return text.parentNode; };
			info.anchor = text;

			insert(target_1, text, anchor);
			insert(target_1, div, anchor);
			add_binding_callback(function () { return ctx.div_binding(div, null); });
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (('componentPromise' in changed) && promise !== (promise = ctx.componentPromise) && handlePromise(promise, info)) ; else {
				info.block.p(changed, assign(assign({}, ctx), info.resolved));
			}

			if (changed.items) {
				ctx.div_binding(null, div);
				ctx.div_binding(div, null);
			}
		},

		i: function intro() {
			if (current) { return; }
			info.block.i();
			current = true;
		},

		o: function outro() {
			for (var i = 0; i < 3; i += 1) {
				var block = info.blocks[i];
				if (block) { block.o(); }
			}

			current = false;
		},

		d: function destroy(detach) {
			info.block.d(detach);
			info = null;

			if (detach) {
				detachNode(text);
				detachNode(div);
			}

			ctx.div_binding(null, div);
		}
	};
}

// (63:2) {:catch error}
function create_catch_block(ctx) {
	var switch_instance_anchor, current;

	var switch_value = ctx.errorComponent;

	function switch_props(ctx) {
		return {
			props: { error: ctx.error },
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c: function create() {
			if (switch_instance) { switch_instance.$$.fragment.c(); }
			switch_instance_anchor = createComment();
		},

		m: function mount(target_1, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target_1, anchor);
			}

			insert(target_1, switch_instance_anchor, anchor);
		},

		p: function update(changed, ctx) {
			var switch_instance_changes = {};
			if (changed.componentPromise) { switch_instance_changes.error = ctx.error; }

			if (switch_value !== (switch_value = ctx.errorComponent)) {
				if (switch_instance) {
					group_outros();
					var old_component = switch_instance;
					on_outro(function () {
						old_component.$destroy();
					});
					old_component.$$.fragment.o();
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					switch_instance.$$.fragment.i();
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i: function intro() {
			if (current) { return; }
			if (switch_instance) { switch_instance.$$.fragment.i(); }

			current = true;
		},

		o: function outro() {
			if (switch_instance) { switch_instance.$$.fragment.o(); }
			current = false;
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(switch_instance_anchor);
			}

			if (switch_instance) { switch_instance.$destroy(detach); }
		}
	};
}

// (62:2) {:then}
function create_then_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (60:27)     <svelte:component this={loadingComponent}
function create_pending_block(ctx) {
	var switch_instance_anchor, current;

	var switch_value = ctx.loadingComponent;

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c: function create() {
			if (switch_instance) { switch_instance.$$.fragment.c(); }
			switch_instance_anchor = createComment();
		},

		m: function mount(target_1, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target_1, anchor);
			}

			insert(target_1, switch_instance_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (switch_value !== (switch_value = ctx.loadingComponent)) {
				if (switch_instance) {
					group_outros();
					var old_component = switch_instance;
					on_outro(function () {
						old_component.$destroy();
					});
					old_component.$$.fragment.o();
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					switch_instance.$$.fragment.i();
				} else {
					switch_instance = null;
				}
			}
		},

		i: function intro() {
			if (current) { return; }
			if (switch_instance) { switch_instance.$$.fragment.i(); }

			current = true;
		},

		o: function outro() {
			if (switch_instance) { switch_instance.$$.fragment.o(); }
			current = false;
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(switch_instance_anchor);
			}

			if (switch_instance) { switch_instance.$destroy(detach); }
		}
	};
}

function create_fragment$2(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.$selectedRoute && ctx.$selectedRoute.route == ctx.route) && create_if_block(ctx);

	return {
		c: function create() {
			if (if_block) { if_block.c(); }
			if_block_anchor = createComment();
		},

		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target_1, anchor) {
			if (if_block) { if_block.m(target_1, anchor); }
			insert(target_1, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (ctx.$selectedRoute && ctx.$selectedRoute.route == ctx.route) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
				if_block.i();
			} else if (if_block) {
				group_outros();
				on_outro(function () {
					if_block.d(1);
					if_block = null;
				});

				if_block.o();
				check_outros();
			}
		},

		i: function intro() {
			if (current) { return; }
			if (if_block) { if_block.i(); }
			current = true;
		},

		o: function outro() {
			if (if_block) { if_block.o(); }
			current = false;
		},

		d: function destroy(detach) {
			if (if_block) { if_block.d(detach); }

			if (detach) {
				detachNode(if_block_anchor);
			}
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	

	var ref = getContext(ROUTER);
	var registerRoute = ref.registerRoute;
	var selectedRoute = ref.selectedRoute;
	var routerErrorComponent = ref.error; if ( routerErrorComponent === void 0 ) routerErrorComponent = null;
	var routerLoadingComponent = ref.loading; if ( routerLoadingComponent === void 0 ) routerLoadingComponent = null;

	// props
	var path = $$props.path;
	var asyncComponent = $$props.asyncComponent; if ( asyncComponent === void 0 ) asyncComponent = null;
	var component = $$props.component; if ( component === void 0 ) component = null;
	var middleware = $$props.middleware; if ( middleware === void 0 ) middleware = [];
	var metadata = $$props.metadata; if ( metadata === void 0 ) metadata = { };
	var error = $$props.error; if ( error === void 0 ) error = null;
	var loading = $$props.loading; if ( loading === void 0 ) loading = null;

	// template variables
	var componentPromise; 
	var target;

	// reactive variables: 
	var loadingComponent, errorComponent;

	var route = { 
		path: path, 
		asyncComponent: asyncComponent, 
		middleware: middleware, 
		metadata: metadata 
	};

	registerRoute(route);

	selectedRoute.subscribe(function (selected) {
		if(!selected) { return; }
		if(asyncComponent && selected && selected.route == route) {
			componentPromise = asyncComponent(); $$invalidate('componentPromise', componentPromise);
			componentPromise.then(
				function (ref) {
					var Component = ref.default;

					return new Component({
						target: target
					});
			}); 
		}
	});

	var $$slot_default = $$props.$$slot_default;
	var $$scope = $$props.$$scope;

	function div_binding($$node, check) {
		target = $$node;
		$$invalidate('target', target);
	}

	var $selectedRoute;
	validate_store(selectedRoute, 'selectedRoute');
	$$self.$$.on_destroy.push(selectedRoute.subscribe(function ($$value) { $selectedRoute = $$value; $$invalidate('$selectedRoute', $selectedRoute); }));

	$$self.$set = function ($$props) {
		if ('path' in $$props) { $$invalidate('path', path = $$props.path); }
		if ('asyncComponent' in $$props) { $$invalidate('asyncComponent', asyncComponent = $$props.asyncComponent); }
		if ('component' in $$props) { $$invalidate('component', component = $$props.component); }
		if ('middleware' in $$props) { $$invalidate('middleware', middleware = $$props.middleware); }
		if ('metadata' in $$props) { $$invalidate('metadata', metadata = $$props.metadata); }
		if ('error' in $$props) { $$invalidate('error', error = $$props.error); }
		if ('loading' in $$props) { $$invalidate('loading', loading = $$props.loading); }
		if ('$$scope' in $$props) { $$invalidate('$$scope', $$scope = $$props.$$scope); }
	};

	$$self.$$.update = function ($$dirty) {
		if ( $$dirty === void 0 ) $$dirty = { loadingComponent: 1, loading: 1, routerLoadingComponent: 1, DefaultLoadingComponent: 1, errorComponent: 1, error: 1, routerErrorComponent: 1, DefaultErrorComponent: 1 };

		if ($$dirty.loadingComponent || $$dirty.loading || $$dirty.routerLoadingComponent || $$dirty.DefaultLoadingComponent) {
			loadingComponent = loading || routerLoadingComponent || Loading; $$invalidate('loadingComponent', loadingComponent);
		}
		if ($$dirty.errorComponent || $$dirty.error || $$dirty.routerErrorComponent || $$dirty.DefaultErrorComponent) {
			errorComponent = error || routerErrorComponent || Error$1; $$invalidate('errorComponent', errorComponent);
		}
	};

	return {
		path: path,
		asyncComponent: asyncComponent,
		component: component,
		middleware: middleware,
		metadata: metadata,
		error: error,
		loading: loading,
		componentPromise: componentPromise,
		target: target,
		loadingComponent: loadingComponent,
		errorComponent: errorComponent,
		route: route,
		div_binding: div_binding,
		$selectedRoute: $selectedRoute,
		$$slot_default: $$slot_default,
		$$scope: $$scope
	};
}

var Route = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function Route(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, instance$1, create_fragment$2, safe_not_equal);

		var ref = this.$$;
		var ctx = ref.ctx;
		var props = options.props || {};
		if (ctx.path === undefined && !('path' in props)) {
			console.warn("<Route> was created without expected prop 'path'");
		}
		if (ctx.asyncComponent === undefined && !('asyncComponent' in props)) {
			console.warn("<Route> was created without expected prop 'asyncComponent'");
		}
		if (ctx.component === undefined && !('component' in props)) {
			console.warn("<Route> was created without expected prop 'component'");
		}
		if (ctx.middleware === undefined && !('middleware' in props)) {
			console.warn("<Route> was created without expected prop 'middleware'");
		}
		if (ctx.metadata === undefined && !('metadata' in props)) {
			console.warn("<Route> was created without expected prop 'metadata'");
		}
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<Route> was created without expected prop 'error'");
		}
		if (ctx.loading === undefined && !('loading' in props)) {
			console.warn("<Route> was created without expected prop 'loading'");
		}
	}

	if ( SvelteComponentDev$$1 ) Route.__proto__ = SvelteComponentDev$$1;
	Route.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	Route.prototype.constructor = Route;

	var prototypeAccessors = { path: { configurable: true },asyncComponent: { configurable: true },component: { configurable: true },middleware: { configurable: true },metadata: { configurable: true },error: { configurable: true },loading: { configurable: true } };

	prototypeAccessors.path.get = function () {
		return this.$$.ctx.path;
	};

	prototypeAccessors.path.set = function (path) {
		this.$set({ path: path });
		flush();
	};

	prototypeAccessors.asyncComponent.get = function () {
		return this.$$.ctx.asyncComponent;
	};

	prototypeAccessors.asyncComponent.set = function (asyncComponent) {
		this.$set({ asyncComponent: asyncComponent });
		flush();
	};

	prototypeAccessors.component.get = function () {
		return this.$$.ctx.component;
	};

	prototypeAccessors.component.set = function (component) {
		this.$set({ component: component });
		flush();
	};

	prototypeAccessors.middleware.get = function () {
		return this.$$.ctx.middleware;
	};

	prototypeAccessors.middleware.set = function (middleware) {
		this.$set({ middleware: middleware });
		flush();
	};

	prototypeAccessors.metadata.get = function () {
		return this.$$.ctx.metadata;
	};

	prototypeAccessors.metadata.set = function (metadata) {
		this.$set({ metadata: metadata });
		flush();
	};

	prototypeAccessors.error.get = function () {
		return this.$$.ctx.error;
	};

	prototypeAccessors.error.set = function (error) {
		this.$set({ error: error });
		flush();
	};

	prototypeAccessors.loading.get = function () {
		return this.$$.ctx.loading;
	};

	prototypeAccessors.loading.set = function (loading) {
		this.$set({ loading: loading });
		flush();
	};

	Object.defineProperties( Route.prototype, prototypeAccessors );

	return Route;
}(SvelteComponentDev));

/* src\Components\test\HomeRoute.html generated by Svelte v3.0.0-alpha20 */

var file$3 = "src\\Components\\test\\HomeRoute.html";

function create_fragment$3(ctx) {
	var h1, text1, p0, strong, text3, pre, text4_value = JSON.stringify(ctx.$selectedRoute.ctx,null,2), text4, text5, p1, text6, a0, text8, p2, text9, a1, text11, p3, text12, a2;

	return {
		c: function create() {
			h1 = createElement("h1");
			h1.textContent = "Homepage";
			text1 = createText("\r\n");
			p0 = createElement("p");
			strong = createElement("strong");
			strong.textContent = "route:";
			text3 = createText("\r\n");
			pre = createElement("pre");
			text4 = createText(text4_value);
			text5 = createText("\r\n");
			p1 = createElement("p");
			text6 = createText("Go to ");
			a0 = createElement("a");
			a0.textContent = "home-alternate";
			text8 = createText("\r\n");
			p2 = createElement("p");
			text9 = createText("Go to ");
			a1 = createElement("a");
			a1.textContent = "regex route";
			text11 = createText("\r\n");
			p3 = createElement("p");
			text12 = createText("Go to ");
			a2 = createElement("a");
			a2.textContent = "named-params route";
			addLoc(h1, file$3, 6, 0, 156);
			addLoc(strong, file$3, 8, 2, 182);
			addLoc(p0, file$3, 7, 0, 175);
			addLoc(pre, file$3, 10, 0, 213);
			a0.href = "/home-alt";
			addLoc(a0, file$3, 12, 8, 282);
			addLoc(p1, file$3, 11, 0, 269);
			a1.href = "/regex-route.123";
			addLoc(a1, file$3, 15, 8, 341);
			addLoc(p2, file$3, 14, 0, 328);
			a2.href = "/named/123";
			addLoc(a2, file$3, 18, 8, 404);
			addLoc(p3, file$3, 17, 0, 391);
		},

		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target, anchor) {
			insert(target, h1, anchor);
			insert(target, text1, anchor);
			insert(target, p0, anchor);
			append(p0, strong);
			insert(target, text3, anchor);
			insert(target, pre, anchor);
			append(pre, text4);
			insert(target, text5, anchor);
			insert(target, p1, anchor);
			append(p1, text6);
			append(p1, a0);
			insert(target, text8, anchor);
			insert(target, p2, anchor);
			append(p2, text9);
			append(p2, a1);
			insert(target, text11, anchor);
			insert(target, p3, anchor);
			append(p3, text12);
			append(p3, a2);
		},

		p: function update(changed, ctx) {
			if ((changed.$selectedRoute) && text4_value !== (text4_value = JSON.stringify(ctx.$selectedRoute.ctx,null,2))) {
				setData(text4, text4_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detach) {
			if (detach) {
				detachNode(h1);
				detachNode(text1);
				detachNode(p0);
				detachNode(text3);
				detachNode(pre);
				detachNode(text5);
				detachNode(p1);
				detachNode(text8);
				detachNode(p2);
				detachNode(text11);
				detachNode(p3);
			}
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	
  var ref = getContext(ROUTER);
  var selectedRoute = ref.selectedRoute;

	var $selectedRoute;
	validate_store(selectedRoute, 'selectedRoute');
	$$self.$$.on_destroy.push(selectedRoute.subscribe(function ($$value) { $selectedRoute = $$value; $$invalidate('$selectedRoute', $selectedRoute); }));

	return { $selectedRoute: $selectedRoute };
}

var HomeRoute = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function HomeRoute(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, instance$2, create_fragment$3, safe_not_equal);
	}

	if ( SvelteComponentDev$$1 ) HomeRoute.__proto__ = SvelteComponentDev$$1;
	HomeRoute.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	HomeRoute.prototype.constructor = HomeRoute;

	return HomeRoute;
}(SvelteComponentDev));

/* src\Components\test\Error.html generated by Svelte v3.0.0-alpha20 */

var file$4 = "src\\Components\\test\\Error.html";

function create_fragment$4(ctx) {
	var h1, text1, pre, text2;

	return {
		c: function create() {
			h1 = createElement("h1");
			h1.textContent = "Custom Error Page";
			text1 = createText("\r\n\r\n");
			pre = createElement("pre");
			text2 = createText(ctx.error);
			addLoc(h1, file$4, 4, 0, 51);
			pre.className = "svelte-kaf4t9";
			addLoc(pre, file$4, 6, 0, 81);
		},

		l: function claim(nodes) {
			throw new Error$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target, anchor) {
			insert(target, h1, anchor);
			insert(target, text1, anchor);
			insert(target, pre, anchor);
			append(pre, text2);
		},

		p: function update(changed, ctx) {
			if (changed.error) {
				setData(text2, ctx.error);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detach) {
			if (detach) {
				detachNode(h1);
				detachNode(text1);
				detachNode(pre);
			}
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	var error = $$props.error; if ( error === void 0 ) error = null;

	$$self.$set = function ($$props) {
		if ('error' in $$props) { $$invalidate('error', error = $$props.error); }
	};

	return { error: error };
}

var Error$2 = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function Error(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, instance$3, create_fragment$4, safe_not_equal);

		var ref = this.$$;
		var ctx = ref.ctx;
		var props = options.props || {};
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<Error> was created without expected prop 'error'");
		}
	}

	if ( SvelteComponentDev$$1 ) Error.__proto__ = SvelteComponentDev$$1;
	Error.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	Error.prototype.constructor = Error;

	var prototypeAccessors = { error: { configurable: true } };

	prototypeAccessors.error.get = function () {
		return this.$$.ctx.error;
	};

	prototypeAccessors.error.set = function (error) {
		this.$set({ error: error });
		flush();
	};

	Object.defineProperties( Error.prototype, prototypeAccessors );

	return Error;
}(SvelteComponentDev));

/* src\Components\test\Loading.html generated by Svelte v3.0.0-alpha20 */

var file$5 = "src\\Components\\test\\Loading.html";

function create_fragment$5(ctx) {
	var div4, div0, text0, div1, text1, div2, text2, div3;

	return {
		c: function create() {
			div4 = createElement("div");
			div0 = createElement("div");
			text0 = createText("\r\n\t");
			div1 = createElement("div");
			text1 = createText("\r\n\t");
			div2 = createElement("div");
			text2 = createText("\r\n\t");
			div3 = createElement("div");
			div0.className = "svelte-1usn4hs";
			addLoc(div0, file$5, 1, 1, 21);
			div1.className = "svelte-1usn4hs";
			addLoc(div1, file$5, 2, 1, 35);
			div2.className = "svelte-1usn4hs";
			addLoc(div2, file$5, 3, 1, 49);
			div3.className = "svelte-1usn4hs";
			addLoc(div3, file$5, 4, 1, 63);
			div4.className = "ring svelte-1usn4hs";
			addLoc(div4, file$5, 0, 0, 0);
		},

		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			append(div4, text0);
			append(div4, div1);
			append(div4, text1);
			append(div4, div2);
			append(div4, text2);
			append(div4, div3);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detach) {
			if (detach) {
				detachNode(div4);
			}
		}
	};
}

var Loading$1 = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function Loading(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, null, create_fragment$5, safe_not_equal);
	}

	if ( SvelteComponentDev$$1 ) Loading.__proto__ = SvelteComponentDev$$1;
	Loading.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	Loading.prototype.constructor = Loading;

	return Loading;
}(SvelteComponentDev));

/* src\App.html generated by Svelte v3.0.0-alpha20 */

var file$6 = "src\\App.html";

// (43:2) <Route    path='/home-alt'    middleware={[exampleRouteMiddleware]}    metadata={exampleRouteMetadata}   >
function create_default_slot_2(ctx) {
	var current;

	var homeroute = new HomeRoute({ $$inline: true });

	return {
		c: function create() {
			homeroute.$$.fragment.c();
		},

		m: function mount(target, anchor) {
			mount_component(homeroute, target, anchor);
		},

		i: function intro() {
			if (current) { return; }
			homeroute.$$.fragment.i();

			current = true;
		},

		o: function outro() {
			if (homeroute) { homeroute.$$.fragment.o(); }
			current = false;
		},

		d: function destroy(detach) {
			homeroute.$destroy(detach);
		}
	};
}

// (65:2) <Route     path='/named/:id'     asyncComponent={() => import('./Components/test/NamedParamsRoute.html')}    >
function create_default_slot_1(ctx) {
	return {
		c: noop,
		m: noop,
		d: noop
	};
}

// (23:1) <Router    hashbang={true}   error={Error}   loading={Loading}   middleware={[exampleRouterMiddleware]}   metadata={exampleRouterMetadata}  >
function create_default_slot(ctx) {
	var text0, text1, text2, current;

	var route0 = new Route({
		props: { path: "/", component: HomeRoute },
		$$inline: true
	});

	var route1 = new Route({
		props: {
		path: "/home-alt",
		middleware: [ctx.exampleRouteMiddleware],
		metadata: ctx.exampleRouteMetadata,
		$$slot_default: [create_default_slot_2],
		$$scope: { ctx: ctx }
	},
		$$inline: true
	});

	var route2 = new Route({
		props: {
		path: /\/regex-route\.(\d+)/,
		asyncComponent: func
	},
		$$inline: true
	});

	var route3 = new Route({
		props: {
		path: "/named/:id",
		asyncComponent: func_1,
		$$slot_default: [create_default_slot_1],
		$$scope: { ctx: ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			route0.$$.fragment.c();
			text0 = createText("\n\t\t\n\t\t");
			route1.$$.fragment.c();
			text1 = createText("\n\t\t\n\t\t");
			route2.$$.fragment.c();
			text2 = createText("\n\t\t\n\t\t");
			route3.$$.fragment.c();
		},

		m: function mount(target, anchor) {
			mount_component(route0, target, anchor);
			insert(target, text0, anchor);
			mount_component(route1, target, anchor);
			insert(target, text1, anchor);
			mount_component(route2, target, anchor);
			insert(target, text2, anchor);
			mount_component(route3, target, anchor);
		},

		p: noop,

		i: function intro() {
			if (current) { return; }
			route0.$$.fragment.i();

			route1.$$.fragment.i();

			route2.$$.fragment.i();

			route3.$$.fragment.i();

			current = true;
		},

		o: function outro() {
			if (route0) { route0.$$.fragment.o(); }
			if (route1) { route1.$$.fragment.o(); }
			if (route2) { route2.$$.fragment.o(); }
			if (route3) { route3.$$.fragment.o(); }
			current = false;
		},

		d: function destroy(detach) {
			route0.$destroy(detach);

			if (detach) {
				detachNode(text0);
			}

			route1.$destroy(detach);

			if (detach) {
				detachNode(text1);
			}

			route2.$destroy(detach);

			if (detach) {
				detachNode(text2);
			}

			route3.$destroy(detach);
		}
	};
}

function create_fragment$6(ctx) {
	var div, current;

	var router = new Router({
		props: {
		hashbang: true,
		error: Error$2,
		loading: Loading$1,
		middleware: [ctx.exampleRouterMiddleware],
		metadata: ctx.exampleRouterMetadata,
		$$slot_default: [create_default_slot],
		$$scope: { ctx: ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			div = createElement("div");
			router.$$.fragment.c();
			addLoc(div, file$6, 21, 0, 721);
		},

		l: function claim(nodes) {
			throw new Error$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			mount_component(router, div, null);
		},

		p: noop,

		i: function intro() {
			if (current) { return; }
			router.$$.fragment.i();

			current = true;
		},

		o: function outro() {
			if (router) { router.$$.fragment.o(); }
			current = false;
		},

		d: function destroy(detach) {
			if (detach) {
				detachNode(div);
			}

			router.$destroy();
		}
	};
}

function func() {
	return import("./RegexRoute.js");
}

function func_1() {
	return import("./NamedParamsRoute.js");
}

function instance$4($$self) {
	

	var exampleRouterMiddleware = function (ctx,next) {
		console.log(("This runs for every route in instance of Router\n" + (JSON.stringify(ctx,null,2)))); 
		next(); 
	};

	var exampleRouteMiddleware = function (ctx,next) {
		console.log(("This runs only for specific routes where it is applied\n" + (JSON.stringify(ctx,null,2)))); 
		next(); 
	};

	var exampleRouterMetadata = { routerId: 123 };
	var exampleRouteMetadata = { pageName: 'Home (Alt)' };

	return {
		exampleRouterMiddleware: exampleRouterMiddleware,
		exampleRouteMiddleware: exampleRouteMiddleware,
		exampleRouterMetadata: exampleRouterMetadata,
		exampleRouteMetadata: exampleRouteMetadata
	};
}

var App = /*@__PURE__*/(function (SvelteComponentDev$$1) {
	function App(options) {
		SvelteComponentDev$$1.call(this, options);
		init(this, options, instance$4, create_fragment$6, safe_not_equal);
	}

	if ( SvelteComponentDev$$1 ) App.__proto__ = SvelteComponentDev$$1;
	App.prototype = Object.create( SvelteComponentDev$$1 && SvelteComponentDev$$1.prototype );
	App.prototype.constructor = App;

	return App;
}(SvelteComponentDev));

var app = new App({
  target: document.body,
  data: {}
});

export default app;
//# sourceMappingURL=app.js.map
