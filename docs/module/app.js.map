{"version":3,"file":"app.js","sources":["../../node_modules/svelte/store/index.mjs","../../node_modules/page/page.mjs","../../src/Components/Router.svelte","../../src/Components/Error.svelte","../../src/Components/Route.svelte","../../src/Components/test/HomeRoute.svelte","../../src/Components/test/Error.svelte","../../src/App.svelte","../../src/app.js"],"sourcesContent":["import { safe_not_equal, noop, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n * @param {Stores} stores input stores\n * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values\n * @param {*=}initial_value when used asynchronously\n */\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","var isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var suffix = res[6];\n    var asterisk = res[7];\n\n    var repeat = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n    var delimiter = prefix || '/';\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$');\n    }\n  }\n\n  return function (obj) {\n    var path = '';\n    var data = obj || {};\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path);\n  var re = tokensToRegExp(tokens, options);\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i]);\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n  var lastToken = tokens[tokens.length - 1];\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken);\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = token.pattern;\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || [];\n\n  if (!isarray(keys)) {\n    options = keys;\n    keys = [];\n  } else if (!options) {\n    options = {};\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/**\n   * Module dependencies.\n   */\n\n  \n\n  /**\n   * Short-cuts for global-object checks\n   */\n\n  var hasDocument = ('undefined' !== typeof document);\n  var hasWindow = ('undefined' !== typeof window);\n  var hasHistory = ('undefined' !== typeof history);\n  var hasProcess = typeof process !== 'undefined';\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var isLocation = hasWindow && !!(window.history.location || window.location);\n\n  /**\n   * The page instance\n   * @api private\n   */\n  function Page() {\n    // public things\n    this.callbacks = [];\n    this.exits = [];\n    this.current = '';\n    this.len = 0;\n\n    // private things\n    this._decodeURLComponents = true;\n    this._base = '';\n    this._strict = false;\n    this._running = false;\n    this._hashbang = false;\n\n    // bound functions\n    this.clickHandler = this.clickHandler.bind(this);\n    this._onpopstate = this._onpopstate.bind(this);\n  }\n\n  /**\n   * Configure the instance of page. This can be called multiple times.\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  Page.prototype.configure = function(options) {\n    var opts = options || {};\n\n    this._window = opts.window || (hasWindow && window);\n    this._decodeURLComponents = opts.decodeURLComponents !== false;\n    this._popstate = opts.popstate !== false && hasWindow;\n    this._click = opts.click !== false && hasDocument;\n    this._hashbang = !!opts.hashbang;\n\n    var _window = this._window;\n    if(this._popstate) {\n      _window.addEventListener('popstate', this._onpopstate, false);\n    } else if(hasWindow) {\n      _window.removeEventListener('popstate', this._onpopstate, false);\n    }\n\n    if (this._click) {\n      _window.document.addEventListener(clickEvent, this.clickHandler, false);\n    } else if(hasDocument) {\n      _window.document.removeEventListener(clickEvent, this.clickHandler, false);\n    }\n\n    if(this._hashbang && hasWindow && !hasHistory) {\n      _window.addEventListener('hashchange', this._onpopstate, false);\n    } else if(hasWindow) {\n      _window.removeEventListener('hashchange', this._onpopstate, false);\n    }\n  };\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  Page.prototype.base = function(path) {\n    if (0 === arguments.length) return this._base;\n    this._base = path;\n  };\n\n  /**\n   * Gets the `base`, which depends on whether we are using History or\n   * hashbang routing.\n\n   * @api private\n   */\n  Page.prototype._getBase = function() {\n    var base = this._base;\n    if(!!base) return base;\n    var loc = hasWindow && this._window && this._window.location;\n\n    if(hasWindow && this._hashbang && loc && loc.protocol === 'file:') {\n      base = loc.pathname;\n    }\n\n    return base;\n  };\n\n  /**\n   * Get or set strict path matching to `enable`\n   *\n   * @param {boolean} enable\n   * @api public\n   */\n\n  Page.prototype.strict = function(enable) {\n    if (0 === arguments.length) return this._strict;\n    this._strict = enable;\n  };\n\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  Page.prototype.start = function(options) {\n    var opts = options || {};\n    this.configure(opts);\n\n    if (false === opts.dispatch) return;\n    this._running = true;\n\n    var url;\n    if(isLocation) {\n      var window = this._window;\n      var loc = window.location;\n\n      if(this._hashbang && ~loc.hash.indexOf('#!')) {\n        url = loc.hash.substr(2) + loc.search;\n      } else if (this._hashbang) {\n        url = loc.search + loc.hash;\n      } else {\n        url = loc.pathname + loc.search + loc.hash;\n      }\n    }\n\n    this.replace(url, null, true, opts.dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  Page.prototype.stop = function() {\n    if (!this._running) return;\n    this.current = '';\n    this.len = 0;\n    this._running = false;\n\n    var window = this._window;\n    this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);\n    hasWindow && window.removeEventListener('popstate', this._onpopstate, false);\n    hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  Page.prototype.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state, this),\n      prev = this.prevContext;\n    this.prevContext = ctx;\n    this.current = ctx.path;\n    if (false !== dispatch) this.dispatch(ctx, prev);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  Page.prototype.back = function(path, state) {\n    var page = this;\n    if (this.len > 0) {\n      var window = this._window;\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      hasHistory && window.history.back();\n      this.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    } else {\n      setTimeout(function() {\n        page.show(page._getBase(), state);\n      });\n    }\n  };\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  Page.prototype.redirect = function(from, to) {\n    var inst = this;\n\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page.call(this, from, function(e) {\n        setTimeout(function() {\n          inst.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        inst.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  Page.prototype.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state, this),\n      prev = this.prevContext;\n    this.prevContext = ctx;\n    this.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) this.dispatch(ctx, prev);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  Page.prototype.dispatch = function(ctx, prev) {\n    var i = 0, j = 0, page = this;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled.call(page, ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  Page.prototype.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return this.exit('*', path);\n    }\n\n    var route = new Route(path, null, this);\n    for (var i = 1; i < arguments.length; ++i) {\n      this.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Handle \"click\" events.\n   */\n\n  /* jshint +W054 */\n  Page.prototype.clickHandler = function(e) {\n    if (1 !== this._which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n    // ensure link\n    // use shadow dom when available if not, fall back to composedPath()\n    // for browsers that only have shady\n    var el = e.target;\n    var eventPath = e.path || (e.composedPath ? e.composedPath() : null);\n\n    if(eventPath) {\n      for (var i = 0; i < eventPath.length; i++) {\n        if (!eventPath[i].nodeName) continue;\n        if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;\n        if (!eventPath[i].href) continue;\n\n        el = eventPath[i];\n        break;\n      }\n    }\n\n    // continue ensure link\n    // el.nodeName for svg links are 'a' instead of 'A'\n    while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName.toUpperCase()) return;\n\n    // check if link is inside an svg\n    // in this case, both href and target are always inside an object\n    var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if(!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return;\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    // svg target is an object and its desired value is in .baseVal property\n    if (svg ? el.target.baseVal : el.target) return;\n\n    // x-origin\n    // note: svg links that are not relative don't call click events (and skip page.js)\n    // consequently, all svg links tested inside page.js are relative and in the same origin\n    if (!svg && !this.sameOrigin(el.href)) return;\n\n    // rebuild path\n    // There aren't .pathname and .search properties in svg links, so we use href\n    // Also, svg href is an object and its desired value is in .baseVal property\n    var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));\n\n    path = path[0] !== '/' ? '/' + path : path;\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (hasProcess && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n    var pageBase = this._getBase();\n\n    if (path.indexOf(pageBase) === 0) {\n      path = path.substr(pageBase.length);\n    }\n\n    if (this._hashbang) path = path.replace('#!', '');\n\n    if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {\n      return;\n    }\n\n    e.preventDefault();\n    this.show(orig);\n  };\n\n  /**\n   * Handle \"populate\" events.\n   * @api private\n   */\n\n  Page.prototype._onpopstate = (function () {\n    var loaded = false;\n    if ( ! hasWindow ) {\n      return function () {};\n    }\n    if (hasDocument && document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      var page = this;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else if (isLocation) {\n        var loc = page._window.location;\n        page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);\n      }\n    };\n  })();\n\n  /**\n   * Event button.\n   */\n  Page.prototype._which = function(e) {\n    e = e || (hasWindow && this._window.event);\n    return null == e.which ? e.button : e.which;\n  };\n\n  /**\n   * Convert to a URL object\n   * @api private\n   */\n  Page.prototype._toURL = function(href) {\n    var window = this._window;\n    if(typeof URL === 'function' && isLocation) {\n      return new URL(href, window.location.toString());\n    } else if (hasDocument) {\n      var anc = window.document.createElement('a');\n      anc.href = href;\n      return anc;\n    }\n  };\n\n  /**\n   * Check if `href` is the same origin.\n   * @param {string} href\n   * @api public\n   */\n\n  Page.prototype.sameOrigin = function(href) {\n    if(!href || !isLocation) return false;\n\n    var url = this._toURL(href);\n    var window = this._window;\n\n    var loc = window.location;\n    return loc.protocol === url.protocol &&\n      loc.hostname === url.hostname &&\n      loc.port === url.port;\n  };\n\n  /**\n   * @api private\n   */\n  Page.prototype._samePath = function(url) {\n    if(!isLocation) return false;\n    var window = this._window;\n    var loc = window.location;\n    return url.pathname === loc.pathname &&\n      url.search === loc.search;\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   * @api private\n   */\n  Page.prototype._decodeURLEncodedURIComponent = function(val) {\n    if (typeof val !== 'string') { return val; }\n    return this._decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  };\n\n  /**\n   * Create a new `page` instance and function\n   */\n  function createPage() {\n    var pageInstance = new Page();\n\n    function pageFn(/* args */) {\n      return page.apply(pageInstance, arguments);\n    }\n\n    // Copy all of the things over. In 2.0 maybe we use setPrototypeOf\n    pageFn.callbacks = pageInstance.callbacks;\n    pageFn.exits = pageInstance.exits;\n    pageFn.base = pageInstance.base.bind(pageInstance);\n    pageFn.strict = pageInstance.strict.bind(pageInstance);\n    pageFn.start = pageInstance.start.bind(pageInstance);\n    pageFn.stop = pageInstance.stop.bind(pageInstance);\n    pageFn.show = pageInstance.show.bind(pageInstance);\n    pageFn.back = pageInstance.back.bind(pageInstance);\n    pageFn.redirect = pageInstance.redirect.bind(pageInstance);\n    pageFn.replace = pageInstance.replace.bind(pageInstance);\n    pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);\n    pageFn.exit = pageInstance.exit.bind(pageInstance);\n    pageFn.configure = pageInstance.configure.bind(pageInstance);\n    pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);\n    pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);\n\n    pageFn.create = createPage;\n\n    Object.defineProperty(pageFn, 'len', {\n      get: function(){\n        return pageInstance.len;\n      },\n      set: function(val) {\n        pageInstance.len = val;\n      }\n    });\n\n    Object.defineProperty(pageFn, 'current', {\n      get: function(){\n        return pageInstance.current;\n      },\n      set: function(val) {\n        pageInstance.current = val;\n      }\n    });\n\n    // In 2.0 these can be named exports\n    pageFn.Context = Context;\n    pageFn.Route = Route;\n\n    return pageFn;\n  }\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page.call(this, '*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path), null, this);\n      for (var i = 1; i < arguments.length; ++i) {\n        this.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      this['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      this.start(path);\n    }\n  }\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n    var page = this;\n    var window = page._window;\n\n    if (page._hashbang) {\n      current = isLocation && this._getBase() + window.location.hash.replace('#!', '');\n    } else {\n      current = isLocation && window.location.pathname + window.location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    isLocation && (window.location.href = ctx.canonicalPath);\n  }\n\n  /**\n   * Escapes RegExp characters in the given string.\n   *\n   * @param {string} s\n   * @api private\n   */\n  function escapeRegExp(s) {\n    return s.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state, pageInstance) {\n    var _page = this.page = pageInstance || page;\n    var window = _page._window;\n    var hashbang = _page._hashbang;\n\n    var pageBase = _page._getBase();\n    if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    var re = new RegExp('^' + escapeRegExp(pageBase));\n    this.path = path.replace(re, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = (hasDocument && window.document.title);\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = this.pathname = parts[0];\n      this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    var page = this.page;\n    var window = page._window;\n    var hashbang = page._hashbang;\n\n    page.len++;\n    if (hasHistory) {\n        window.history.pushState(this.state, this.title,\n          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n    }\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    var page = this.page;\n    if (hasHistory) {\n        page._window.history.replaceState(this.state, this.title,\n          page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n    }\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options, page) {\n    var _page = this.page = page || globalPage;\n    var opts = options || {};\n    opts.strict = opts.strict || page._strict;\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);\n  }\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = this.page._decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Module exports.\n   */\n\n  var globalPage = createPage();\n  var page_js = globalPage;\n  var default_1 = globalPage;\n\npage_js.default = default_1;\n\nexport default page_js;\n","<!-- <script context=\"module\">\r\n\texport const ROUTER = { }; \r\n</script> -->\r\n\r\n<script>\r\n\timport { setContext, onMount, afterUpdate } from 'svelte';\r\n\timport { writable } from 'svelte/store';\r\n\timport page from 'page';\r\n\t\r\n\tlet selectedRoute = writable(null);\r\n\r\n\texport let middleware = [];\r\n\texport let hashbang = false;\r\n\texport let metadata = { }; \r\n\texport let error = null;\r\n\texport let loading = null;\r\n\texport let base = '/';\r\n\r\n\tconst customizeCtx = ({ metadata: route }) => (ctx,next) => { \r\n\t\tctx.metadata = { \r\n\t\t\troute, \r\n\t\t\trouter: metadata\r\n\t\t};\r\n\t\tctx.navigate = page;\r\n\t\tnext(); \r\n\t};\r\n\r\n\tconst routeMiddleware = route => (ctx) => { \r\n\t\tselectedRoute.set({ctx, route});\r\n\t\t// todo: will need to call next if there are child routes\r\n\t};\r\n\t\r\n\tsetContext('ROUTER', { \r\n\t\tregisterRoute(route) { \r\n\t\t\tpage(\r\n\t\t\t\troute.path, \t\r\n\t\t\t\tcustomizeCtx(route),\r\n\t\t\t\t...middleware, \r\n\t\t\t\t...route.middleware,\r\n\t\t\t\trouteMiddleware(route)\r\n\t\t\t); \r\n\t\t}, \r\n\t\terror,\r\n\t\tloading,\r\n\t\tselectedRoute,\r\n\t\tpage\r\n\t});\r\n\r\n\tonMount(() => {\r\n\t\tif (base !== '/') {\r\n\t\t\tpage.base(base)\r\n\t\t}\r\n\t\tpage({});\r\n\t});\r\n\r\n</script>\r\n\r\n<slot></slot>\r\n","<script>\r\n  export let error = null;\r\n</script>\r\n\r\n<h1>ERROR!</h1>\r\n\r\n<p>Error: </p>\r\n{error}","<script>\r\n\timport { getContext, onDestroy } from 'svelte';\r\n\timport DefaultLoadingComponent from './Loading.svelte';\r\n\timport DefaultErrorComponent from './Error.svelte';\r\n\r\n\tconst {\r\n\t\tregisterRoute, \r\n\t\tselectedRoute, \r\n\t\terror: routerErrorComponent=null, \r\n\t\tloading: routerLoadingComponent=null\r\n\t} = getContext('ROUTER');\r\n\r\n\t// props\r\n\texport let path; \r\n\texport let asyncComponent = null;\r\n\texport let component = null;\r\n\texport let middleware = [];\r\n\texport let metadata = { }\r\n\texport let error = null;\r\n\texport let loading = null;\r\n\r\n\t// template variables\r\n\tlet componentPromise; \r\n\tlet target;\r\n\tlet routeError = null;\r\n\tlet routeIsActive = false;\r\n\r\n\t// reactive variables: \r\n\tlet loadingComponent, errorComponent; \r\n\t$: loadingComponent = loading || routerLoadingComponent || DefaultLoadingComponent;\r\n\t$: errorComponent = error || routerErrorComponent || DefaultErrorComponent;\r\n\r\n\tconst route = { \r\n\t\tpath, \r\n\t\tasyncComponent, \r\n\t\tmiddleware, \r\n\t\tmetadata \r\n\t};\r\n\tregisterRoute(route);\r\n\r\n\tselectedRoute.subscribe(selected => {\r\n\t\tif(!selected || selected.route !== route) {\r\n\t\t\trouteIsActive = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(asyncComponent && selected && selected.route == route) {\r\n\t\t\tcomponentPromise = asyncComponent();\r\n\t\t\tif(routeIsActive) {\r\n\t\t\t\tcomponent.$set({ selectedRoute });\r\n\t\t\t} else {\r\n\t\t\t\trouteIsActive = true;\r\n\t\t\t\tcomponentPromise.then(\r\n\t\t\t\t\t({default: Component}) => {\r\n\t\t\t\t\t\tcomponent = new Component({\r\n\t\t\t\t\t\t\ttarget, \r\n\t\t\t\t\t\t\tprops: { selectedRoute }\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\treturn component;\r\n\t\t\t\t}); \r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n</script>\r\n\r\n{#if $selectedRoute && $selectedRoute.route == route}\r\n\t{#if asyncComponent}\r\n\t\t{#await componentPromise}\r\n\t\t\t<svelte:component this={loadingComponent} />\r\n\t\t{:then}\r\n\t\t{:catch error}\r\n\t\t\t<svelte:component this={errorComponent} error={error} />\r\n\t\t{/await}\r\n\t\t<div bind:this={target} class=\"route-container\"></div>\r\n\t{:else if component}\r\n\t\t<svelte:component this={component} {selectedRoute} />\r\n\t{:else}\r\n\t\t<slot></slot>\r\n\t{/if}\r\n{/if}\r\n","<script>\r\n  import { getContext } from 'svelte'; \r\n  import Page from './Page.svelte';\r\n  // import { ROUTER } from '../Router.svelte';\r\n  let { selectedRoute } = getContext('ROUTER'); \r\n</script>\r\n\r\n<Page>\r\n  <h1>Homepage</h1>\r\n  <p>\r\n    <strong>route:</strong>\r\n  </p>\r\n  <pre>{JSON.stringify($selectedRoute.ctx.params,null,2)}</pre>\r\n  <p>\r\n    Go to <a href=\"/svelte-router/home-alt\">home-alternate</a>\r\n  </p>\r\n  <p>\r\n    Go to <a href=\"/svelte-router/regex-route.123\">regex route</a>\r\n  </p>\r\n  <p>\r\n    Go to <a href=\"/svelte-router/named/123\">named-params route</a>\r\n  </p>\r\n</Page>\r\n","<script>\r\n  export let error = null;\r\n</script>\r\n\r\n<h1>Custom Error Page</h1>\r\n\r\n<pre>\r\n  {error}\r\n</pre>\r\n\r\n<style>\r\n  pre { \r\n    padding: 40px;\r\n    font-size: 14px;\r\n    background-color: rgba(255,0,0,0.2); \r\n  }\r\n</style>","<script>\r\n\timport Router from './Components/Router.svelte';\r\n\timport Route from './Components/Route.svelte';\r\n\timport HomeRoute from './Components/test/HomeRoute.svelte';\r\n\timport Error from './Components/test/Error.svelte';\r\n\timport Loading from './Components/test/Loading.svelte';\r\n\r\n\tconst exampleRouterMiddleware = (ctx,next) => {\r\n\t\tconsole.log(`This runs for every route in instance of Router\\n`, ctx); \r\n\t\tnext(); \r\n\t};\r\n\r\n\tconst exampleRouteMiddleware = (ctx,next) => {\r\n\t\tconsole.log(`This runs only for specific routes where it is applied\\n`, ctx); \r\n\t\tnext(); \r\n\t};\r\n\r\n\tconst exampleRouterMetadata = { routerId: 123 };\r\n\tconst exampleRouteMetadata = { pageName: 'Home (Alt)' }; \r\n\r\n\tlet base = '/svelte-router';\r\n</script>\r\n\r\n<div>\r\n\t<Router \r\n\t\thashbang={true}\r\n\t\terror={Error}\r\n\t\tloading={Loading}\r\n\t\tmiddleware={[exampleRouterMiddleware]}\r\n\t\tmetadata={exampleRouterMetadata}\r\n\t>\r\n\t\t<!-- \r\n\t\t\tRoute paths can be strings (exact matches or express-style \r\n\t\t\tnamed-params) or regex \r\n\t\t\r\n\t\t\tComponents can  be embedded via the {component} prop \r\n\t\t-->\r\n\t\t<Route \r\n\t\t\tpath='/svelte-router' \r\n\t\t\tcomponent={HomeRoute}\r\n\t\t/>\r\n\t\t<!-- \r\n\t\t\tComponents/DOM can also be embedded via the default route slot\r\n\t\t-->\r\n\t\t<Route\r\n\t\t\tpath='/svelte-router/home-alt'\r\n\t\t\tmiddleware={[exampleRouteMiddleware]}\r\n\t\t\tmetadata={exampleRouteMetadata}\r\n\t\t>\r\n\t\t\t<HomeRoute />\r\n\t\t</Route>\r\n\t\t<!-- \r\n\t\t\tasyncComponent is an optional prop which provides a function which \r\n\t\t\tdynamically imports the necessary component for a route - for use \r\n\t\t\twith codesplitting.  \r\n\t\t-->\r\n\t\t<Route \r\n\t\t\tpath={/\\/svelte-router\\/regex-route\\.(\\d+)/} \r\n\t\t\tasyncComponent={() => import('./Components/test/RegexRoute.svelte')} \r\n\t\t/>\r\n\t\t<!-- \r\n\t\t\tyou can override router-wide error and loading \r\n\t\t\tcomponents by specifying 'loading' and 'error' props\r\n\t\t-->\r\n\t\t<Route \r\n\t\t\tpath='/svelte-router/named/:id' \r\n\t\t\tasyncComponent={() => import('./Components/test/NamedParamsRoute.svelte')} \r\n\t\t>\r\n\t\t</Route>\r\n\t</Router>\r\n</div>\r\n","import App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.body,\n  data: {}\n});\n\nexport default app;\n"],"names":["const","subscriber_queue","isarray","Array","isArray","arr","Object","prototype","toString","call","pathToRegexp_1","pathToRegexp","parse_1","parse","compile_1","str","tokensToFunction","tokensToFunction_1","tokensToRegExp_1","tokensToRegExp","PATH_REGEXP","RegExp","join","res","tokens","key","index","path","exec","m","escaped","offset","slice","length","push","prefix","name","capture","group","suffix","asterisk","repeat","optional","delimiter","pattern","escapeGroup","substr","matches","i","obj","data","token","segment","value","TypeError","j","encodeURIComponent","test","escapeString","replace","attachKeys","re","keys","flags","options","sensitive","strict","end","route","lastToken","endsWithSlash","groups","source","match","regexpToRegexp","parts","arrayToRegexp","stringToRegexp","compile","loaded","hasDocument","document","hasWindow","window","hasHistory","history","hasProcess","process","clickEvent","ontouchstart","isLocation","location","Page","this","callbacks","exits","current","len","_decodeURLComponents","_base","_strict","_running","_hashbang","clickHandler","bind","_onpopstate","page","fn","Route","arguments","middleware","start","Context","state","pageInstance","_page","_window","hashbang","pageBase","_getBase","indexOf","canonicalPath","title","querystring","_decodeURLEncodedURIComponent","pathname","params","hash","split","globalPage","opts","method","regexp","configure","decodeURLComponents","_popstate","popstate","_click","click","addEventListener","removeEventListener","base","loc","protocol","enable","dispatch","url","search","stop","show","ctx","prev","prevContext","handled","pushState","back","setTimeout","redirect","from","to","inst","e","init","save","nextEnter","href","nextExit","exit","_which","metaKey","ctrlKey","shiftKey","defaultPrevented","el","target","eventPath","composedPath","nodeName","toUpperCase","parentNode","svg","constructor","hasAttribute","getAttribute","link","_samePath","baseVal","sameOrigin","orig","preventDefault","readyState","undefined","event","which","button","_toURL","URL","anc","createElement","hostname","port","val","decodeURIComponent","replaceState","self","next","qsIndex","hasOwnProperty","createPage","pageFn","apply","create","defineProperty","get","set","page_js","default_1","let","selectedRoute","noop","subscribers","new_value","safe_not_equal","run_queue","s","run","invalidate","subscriber","splice","writable","customizeCtx","ref","metadata","router","navigate","routeMiddleware","setContext","registerRoute","error","loading","onMount","default","asyncComponent","component","componentPromise","errorComponent","loadingComponent","$selectedRoute","getContext","routeIsActive","subscribe","selected","$set","then","Component","props","routerLoadingComponent","DefaultLoadingComponent","routerErrorComponent","DefaultErrorComponent","JSON","stringify","HomeRoute","exampleRouteMiddleware","exampleRouteMetadata","func","func_1","Error","Loading","exampleRouterMiddleware","exampleRouterMetadata","console","log","routerId","pageName","body"],"mappings":"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"}