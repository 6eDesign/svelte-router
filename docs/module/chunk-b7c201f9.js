function noop(){}function assign(n,t){for(var e in t)n[e]=t[e];return n}function isPromise(n){return n&&"function"==typeof n.then}function run(n){return n()}function blankObject(){return Object.create(null)}function run_all(n){n.forEach(run)}function is_function(n){return"function"==typeof n}function safe_not_equal(n,t){return n!=n?t==t:n!==t||n&&"object"==typeof n||"function"==typeof n}function create_slot(n,t,e){if(n){const o=get_slot_context(n,t,e);return n[0](o)}}function get_slot_context(n,t,e){return n[1]?assign({},assign(t.$$scope.ctx,n[1](e?e(t):{}))):t.$$scope.ctx}function append(n,t){n.appendChild(t)}function insert(n,t,e){n.insertBefore(t,e)}function detachNode(n){n.parentNode.removeChild(n)}function createElement(n){return document.createElement(n)}function createText(n){return document.createTextNode(n)}function createComment(){return document.createComment("")}function children(n){return Array.from(n.childNodes)}function setData(n,t){n.data=""+t}let outros,current_component;function group_outros(){outros={remaining:0,callbacks:[]}}function check_outros(){outros.remaining||run_all(outros.callbacks)}function on_outro(n){outros.callbacks.push(n)}function set_current_component(n){current_component=n}function get_current_component(){if(!current_component)throw new Error("Function called outside component initialization");return current_component}function onMount(n){get_current_component().$$.on_mount.push(n)}function setContext(n,t){get_current_component().$$.context.set(n,t)}function getContext(n){return get_current_component().$$.context.get(n)}let dirty_components=[],update_scheduled=!1;const binding_callbacks=[],render_callbacks=[];function schedule_update(){update_scheduled||(update_scheduled=!0,queue_microtask(flush))}function add_render_callback(n){render_callbacks.push(n)}function add_binding_callback(n){binding_callbacks.push(n)}function flush(){const n=new Set;do{for(;dirty_components.length;){const n=dirty_components.shift();set_current_component(n),update(n.$$)}for(;binding_callbacks.length;)binding_callbacks.shift()();for(;render_callbacks.length;){const t=render_callbacks.pop();n.has(t)||(t(),n.add(t))}}while(dirty_components.length);update_scheduled=!1}function update(n){n.fragment&&(n.update(n.dirty),run_all(n.before_render),n.fragment.p(n.dirty,n.ctx),n.dirty=null,n.after_render.forEach(add_render_callback))}function queue_microtask(n){Promise.resolve().then(()=>{update_scheduled&&n()})}function handlePromise(n,t){var e=t.token={};function o(n,o,r,c){if(t.token!==e)return;t.resolved=r&&{[r]:c};const a=assign(assign({},t.ctx),t.resolved),u=n&&(t.current=n)(a);t.block&&(t.blocks?t.blocks.forEach((n,e)=>{e!==o&&n&&(group_outros(),on_outro(()=>{n.d(1),t.blocks[e]=null}),n.o(),check_outros())}):t.block.d(1),u.c(),u.m(t.mount(),t.anchor),u.i&&u.i(),flush()),t.block=u,t.blocks&&(t.blocks[o]=u)}if(isPromise(n)){if(n.then(n=>{o(t.then,1,t.value,n)},n=>{o(t.catch,2,t.error,n)}),t.current!==t.pending)return o(t.pending,0),!0}else{if(t.current!==t.then)return o(t.then,1,t.value,n),!0;t.resolved={[t.value]:n}}}function mount_component(n,t,e){const{fragment:o,on_mount:r,on_destroy:c,after_render:a}=n.$$;o.m(t,e),add_render_callback(()=>{const t=r.map(run).filter(is_function);c?c.push(...t):run_all(t),n.$$.on_mount=[]}),a.forEach(add_render_callback)}function destroy(n,t){n.$$&&(run_all(n.$$.on_destroy),n.$$.fragment.d(t),n.$$.on_destroy=n.$$.fragment=null,n.$$.ctx={})}function make_dirty(n,t){n.$$.dirty||(dirty_components.push(n),schedule_update(),n.$$.dirty={}),n.$$.dirty[t]=!0}function init(n,t,e,o,r){const c=current_component;set_current_component(n);const a=t.props||{},u=n.$$={fragment:null,ctx:null,update:noop,not_equal:r,bound:blankObject(),on_mount:[],on_destroy:[],before_render:[],after_render:[],context:new Map(c?c.$$.context:[]),callbacks:blankObject(),dirty:null};let s=!1;u.ctx=e?e(n,a,(t,e)=>{if(u.bound[t]&&u.bound[t](e),u.ctx){const o=r(e,u.ctx[t]);return s&&o&&make_dirty(n,t),u.ctx[t]=e,o}}):a,u.update(),s=!0,run_all(u.before_render),u.fragment=o(u.ctx),t.target&&(t.hydrate?u.fragment.l(children(t.target)):u.fragment.c(),mount_component(n,t.target,t.anchor),t.intro&&n.$$.fragment.i&&n.$$.fragment.i(),flush()),set_current_component(c)}class SvelteComponent{$destroy(){destroy(this,!0),this.$destroy=noop}$on(n,t){const e=this.$$.callbacks[n]||(this.$$.callbacks[n]=[]);return e.push(t),()=>{const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}$set(){}}export{run_all as a,noop as b,SvelteComponent as c,assign as d,create_slot as e,get_slot_context as f,init as g,safe_not_equal as h,setContext as i,onMount as j,add_binding_callback as k,createComment as l,createElement as m,createText as n,detachNode as o,flush as p,handlePromise as q,insert as r,getContext as s,mount_component as t,append as u,setData as v};
//# sourceMappingURL=chunk-b7c201f9.js.map
